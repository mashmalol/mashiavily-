import { Router } from 'express';
import { promises as fs } from 'fs';
import path from 'path';

const router = Router();

export interface GeneratedExploit {
  id: string;
  title: string;
  description: string;
  code: string;
  targetContract?: string;
  vulnerabilityType: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  author: string;
  timestamp: string;
  tags: string[];
}

/**
 * In-memory storage for exploits (replace with database in production)
 */
let exploits: GeneratedExploit[] = [];

/**
 * POST /api/exploits
 * Submit a generated exploit from chat interaction
 */
router.post('/', async (req, res) => {
  try {
    const {
      title,
      description,
      code,
      targetContract,
      vulnerabilityType,
      severity,
      author,
      tags
    } = req.body;

    if (!title || !code || !vulnerabilityType) {
      return res.status(400).json({ 
        error: 'Missing required fields: title, code, vulnerabilityType' 
      });
    }

    const exploit: GeneratedExploit = {
      id: `exploit-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      title,
      description: description || '',
      code,
      targetContract,
      vulnerabilityType,
      severity: severity || 'medium',
      author: author || 'Anonymous',
      timestamp: new Date().toISOString(),
      tags: tags || []
    };

    exploits.push(exploit);

    // Optionally save to file system
    await saveExploitToFile(exploit);

    res.json({ 
      success: true, 
      exploit,
      message: 'Exploit submitted successfully. The Observer has documented this vulnerability pattern.' 
    });
  } catch (error) {
    console.error('Error submitting exploit:', error);
    res.status(500).json({ 
      error: 'Failed to submit exploit',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * GET /api/exploits
 * Retrieve all submitted exploits
 */
router.get('/', (req, res) => {
  try {
    const { severity, vulnerabilityType, limit } = req.query;

    let filtered = [...exploits];

    // Filter by severity
    if (severity) {
      filtered = filtered.filter(e => e.severity === severity);
    }

    // Filter by vulnerability type
    if (vulnerabilityType) {
      filtered = filtered.filter(e => 
        e.vulnerabilityType.toLowerCase().includes((vulnerabilityType as string).toLowerCase())
      );
    }

    // Limit results
    if (limit) {
      filtered = filtered.slice(0, parseInt(limit as string));
    }

    // Sort by timestamp (newest first)
    filtered.sort((a, b) => 
      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
    );

    res.json({ 
      exploits: filtered,
      total: filtered.length 
    });
  } catch (error) {
    console.error('Error fetching exploits:', error);
    res.status(500).json({ 
      error: 'Failed to fetch exploits',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * GET /api/exploits/:id
 * Retrieve a specific exploit by ID
 */
router.get('/:id', (req, res) => {
  try {
    const { id } = req.params;
    const exploit = exploits.find(e => e.id === id);

    if (!exploit) {
      return res.status(404).json({ error: 'Exploit not found' });
    }

    res.json({ exploit });
  } catch (error) {
    console.error('Error fetching exploit:', error);
    res.status(500).json({ 
      error: 'Failed to fetch exploit',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * DELETE /api/exploits/:id
 * Delete an exploit (admin only in production)
 */
router.delete('/:id', (req, res) => {
  try {
    const { id } = req.params;
    const index = exploits.findIndex(e => e.id === id);

    if (index === -1) {
      return res.status(404).json({ error: 'Exploit not found' });
    }

    const deleted = exploits.splice(index, 1)[0];
    
    res.json({ 
      success: true, 
      message: 'Exploit deleted',
      exploit: deleted 
    });
  } catch (error) {
    console.error('Error deleting exploit:', error);
    res.status(500).json({ 
      error: 'Failed to delete exploit',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * GET /api/exploits/stats/summary
 * Get statistics about submitted exploits
 */
router.get('/stats/summary', (req, res) => {
  try {
    const stats = {
      total: exploits.length,
      bySeverity: {
        critical: exploits.filter(e => e.severity === 'critical').length,
        high: exploits.filter(e => e.severity === 'high').length,
        medium: exploits.filter(e => e.severity === 'medium').length,
        low: exploits.filter(e => e.severity === 'low').length
      },
      byVulnerabilityType: {} as Record<string, number>,
      recentSubmissions: exploits
        .slice(-5)
        .reverse()
        .map(e => ({ id: e.id, title: e.title, timestamp: e.timestamp }))
    };

    // Count by vulnerability type
    exploits.forEach(e => {
      stats.byVulnerabilityType[e.vulnerabilityType] = 
        (stats.byVulnerabilityType[e.vulnerabilityType] || 0) + 1;
    });

    res.json({ stats });
  } catch (error) {
    console.error('Error fetching stats:', error);
    res.status(500).json({ 
      error: 'Failed to fetch statistics',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

/**
 * Saves exploit to file system for persistence
 */
async function saveExploitToFile(exploit: GeneratedExploit): Promise<void> {
  try {
    const exploitsDir = path.join(__dirname, '../../data/exploits');
    
    // Create directory if it doesn't exist
    await fs.mkdir(exploitsDir, { recursive: true });

    // Save as JSON file
    const filename = `${exploit.id}.json`;
    const filepath = path.join(exploitsDir, filename);
    
    await fs.writeFile(filepath, JSON.stringify(exploit, null, 2));

    // Also save the Solidity code separately
    if (exploit.code.includes('pragma solidity')) {
      const solFilename = `${exploit.id}.sol`;
      const solFilepath = path.join(exploitsDir, solFilename);
      await fs.writeFile(solFilepath, exploit.code);
    }
  } catch (error) {
    console.error('Error saving exploit to file:', error);
    // Don't throw - in-memory storage still works
  }
}

/**
 * Load exploits from file system on startup
 */
export async function loadExploitsFromFiles(): Promise<void> {
  try {
    const exploitsDir = path.join(__dirname, '../../data/exploits');
    
    // Create directory if it doesn't exist
    await fs.mkdir(exploitsDir, { recursive: true });

    const files = await fs.readdir(exploitsDir);
    const jsonFiles = files.filter(f => f.endsWith('.json'));

    for (const file of jsonFiles) {
      const filepath = path.join(exploitsDir, file);
      const content = await fs.readFile(filepath, 'utf-8');
      const exploit = JSON.parse(content) as GeneratedExploit;
      exploits.push(exploit);
    }

    console.log(`Loaded ${exploits.length} exploits from file system`);
  } catch (error) {
    console.error('Error loading exploits from files:', error);
  }
}

export default router;
